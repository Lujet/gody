package main

/*
 * 切片的内部实现和基础功能:
 * 切片这种数据结构便于使用和管理数据集合
 * 切片围绕动态数组的概念构建, 可按需增长和缩小
 *
 * 内置函数 append 实现切片的动态增长, 可以快速且高效的增长切片，
 * 还可以通过切片再次切片来缩小一个切片的大小
 *
 * 切片的底层内存是在连续块中分配的，所以切片能获得索引, 迭代以及
 * 为垃圾回收优化的好处
 */

// 理解:
// 切片可以使用索引，且非常高效， 即new即用，其内存一定是连续的，
// 切片可以动态增长似乎看起来其底层数据结构是链表，但内置函数
// append 的原理是如果增长的长度超出切片底层数组的容量就会创建
// 一个新的底层数组来存放append后的数据，所以切片的增长是新开辟
// 出一片新的连续的内存，所以切片的底层内存是连续的
// 应该注意到，切片是一个很小的对象，其对底层数组进行了抽象，
// 并提供相关的操作方法，其有三个字段的数据结构，这些数据结构
// 包含了go语言操作底层数组的元数据

// 切片的三个字段:
// 指向底层数组的指针
// 切片可访问的元素个数(长度)
// 切片允许增长到的元素个数(容量)

import (
	"fmt"
	"time"
)

func main() {
	// 切片的创建
	slice := make([]string, 5)

	//--------------------------------------------------------- 概念语法相关

	// 1, 创建切片
	slice := make([]string, 5)    // 长度和容量都是5
	slice := make([]string, 3, 5) // 长度为3， 容量为5

	//---------------------------------------------------------
	//  分配包含100万个整型值的切片
	slice := make([]int, 1e6)

	// 传递给函数 foo
	start := time.Now()
	slice = foo(slice)
	duration := time.Since(start)
	fmt.Println(duration)
}

func foo(slice []int) []int {
	// ...
	return slice
}

// foo
// 142ns, 对比数组在函数间的传递，就可发现传递切片的性能较好
// 由于切片的尺寸很小， 在函数间传递切片成本很低

// 在 64 位架构上，一个切片需要 24 字节的内存: 如下
// 指针字段需要 8 字节（内存按位寻址， 表示一个地址需要64位, 即8字节）
// 长度字段需要 8 字节(?)
// 容量字段需求 8 字节(?)
// 由于与切片关联的数据包含在底层数组里， 不属于切片本身，所有将切片复制到
// 任意函数的时候， 对底层数组的大小都不会有影响，复制时只会复制切片本身，
// 不会涉及到底层数组
