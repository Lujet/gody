package main

import "fmt"

//
// 映射: map
// 可以使用类似处理数组和切片的方式迭代映射中的元素, 但映射是无序的， 即
// 每次迭代映射的时候顺序都是不一致的
// 无序的原因是映射的实现使用了散列表
// 映射的散列表包含一组桶，在存储、删除或查找键值对的时候，所有的操作都要
// 先选择一个桶, 把操作映射时指定的键传给映射的散列函数，就能选中对应的桶
// 这个散列函数的目的是生成一个索引，最终将键值对分布到所有可用的桶里
//
//
// todo:
// 随着映射存储的增加，索引分布越均匀，访问键值对的速度就越快???
// 映射通过合理数量的桶来平衡键值对的分布
// 对 go 语言的映射来说，生成的散列键的一部分，具体来说是低位(LOB),
// 被用来选择桶
//
//  映射的键可以是任意值，这个值的类型可以是内置的类型，也可以是结构
// 类型，只要这个值可以使用 == 运算符做比较，切片、函数以及包含切片的
// 结构类型由于具有引用语义(todo)，不能作为映射的键， 使用这些类型会
// 造成编译错误
//
//

func main() {
	// 在函数间传递映射并不会制造出该映射的一个副本，当传递映射给一个函数，
	// 并对这个映射做了修改时，所有对这个映射的引用都会感知到这个修改
	// 此特性和切片类似， 保证可以用最小的成本来复制映射

	colors := map[int]string{
		1: "测试1",
		2: "测试2",
		3: "测试3",
		4: "测试4",
	}

	for key, value := range colors {
		fmt.Printf("Key: %v value: %s\n", key, value)
	}

	fmt.Println("----------------------------")
	removeColor(colors, 1)
	for key, value := range colors {
		fmt.Printf("Key: %v value: %s\n", key, value)
	}
}

func removeColor(colors map[int]string, key int) {
	delete(colors, key)
}

//
// Key: 2 value: 测试2
// Key: 3 value: 测试3
// Key: 4 value: 测试4
// Key: 1 value: 测试1
// ----------------------------
// Key: 3 value: 测试3
// Key: 4 value: 测试4
// Key: 2 value: 测试2
//
