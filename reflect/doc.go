package main

/*
 * TODO: 理解
 * 在编译时不知道类型的情况下，可更新变量、在运行时查看值、调用方法以及直接
 * 对它们的布局进行操作，这种机制称为反射(reflection)
 *
 * 反射也让我们可以把类型当做头等值???
 *
 *
 *  本节讨论反射功能以及它如何增强语言的表达能力，特别是它在实现两个重要API
 *  中的关键作用, 这两个API分别为:
 *  fmt包提供的字符串格式化功能
 *  encoding/json 和 encoding/xml 这种包提供的协议编码功能
 *
 *  反射在 text/template 和 html/template 包提供的模板机制中也很重要.
 *
 *  反射的推导比较复杂，也非随意使用而设计，因此上述包使用反射来实现，
 *  但并没有在包自己的API中暴露反射.
 *
 */

/*
 * go 程序设计 Page274
 * 反射是一个功能和表达能力都很强的工具，但应该谨慎使用, 有以下3点原因
 *
 *  - 基于反射的代码是很脆弱的:
 *			能导致编译器报告类型错误的每种写法，在反射中都有一个对应的误用
 *			方法。编译器在编译时就能报告错误，而反射错误则要等到执行时才以
 *			崩溃的方式来报告.
 *			所以对于每一个 reflect.Value , 都需要仔细检查它的类型, 是否可寻址,
 *			是否可设置以及设置的值的类型检查
 *
 *			反射降低了自动重构和分析工具的安全性与准确度, 因为自动重构和分析
 *          工具不能检测到类型信息
 *
 *
 *  - 类型也算是某种类型的文档，而反射的相关操作无法做静态类型检查，所以大量
 *    使用反射的代码是难以理解的，对于接受 interface{} 或者 reflect.Value
 *    的函数， 一定要写清楚期望的参数类型和其他限制条件(即不变量)
 *
 *
 *  - 基于反射的函数会比为特定类型优化的函数慢一两个数量级, 在一个典型的程序
 *    中，大部分函数与性能无关，所以为了让程序更清晰可以使用反射. 测试就适合
 *    使用反射，因为大部分测试都使用小数据集，但对于关键路径上的函数，则最好
 *    避免使用反射.
 *
 */
