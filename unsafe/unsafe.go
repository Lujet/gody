package main

/*
	低级编程:
	go 语言的设计确保了一些安全的属性从而限制了 go 程序可能 "出错" 的途径, 在
	编译期间, 类型检查检测把结果赋给不正确类型的操作; 严格的类型转换规则阻止
	了直接对内置类型字符串, map, slice 和通道的内部访问;

	类型的很多实现细节无法通过 go 程序访问, 如聚合类型(结构体)的内存布局或者
	一个函数对应的机器码, 也无法了解识别出当前运行的 goroutine 所在的线程;
	go 协程调度器可以自由的将 goroutine 从一个线程移动到另一个线程; 指针会
	识别所引用的变量, 而不是暴露出变量的地址; 在垃圾回收的过程中, 变量地址
	会被移动, 同时指针也会透明的更新;

	go 通过隐藏底层细节, 使程序高度可移植, 因为语言的语义很大程度上独立于
	任何特定的编译器, 操作系统和 cpu 架构;

	有时放弃保障实现最可能的高性能, 和以其他语言编写的库进行交互或实现一个
	无法使用纯 go 描述的函数; 此时就可用 golang 提供的 unsafe 包, 但 unsafe
	不可滥用, 如果不考虑清楚, 则会带来各种不可预测的, 奇怪的, 非局部性错误;

	包 unsafe 是由编译器实现的(TODO), 提供了对内置特性的访问功能, 而这些特性
	一般是不可见的(其他包中); 因为 unsafe 包暴露了 go 详细的内存布局, 所以
	正如其包名一样提醒使用其时应多加小心;
	unsafe 广泛使用在和操作系统交互的低级包(runtime, os, syscall, net)中,
	但是普通程序从来不需要使用 unsafe;


	unsafe.Sizeof
		获取参数在内存中占用的字节长度, 参数可以是任意类型的表达式, 并不会计算
		表达式; 返回一个 uintptr 类型的常量表达式

	unsafe.Alignof
		获取参数类型要求的对齐方式, 参数可以是任意类型的表达式, 并且返回一个
		常量; 特别的, 布尔类型和数值类型对齐到它们的长度(最大8字节), 而其他的
		类型则按字对齐

	unsafe.Offsetof
		计算结构体成员相对于结构体起始地址的偏移值, 如果有内存空位也计算在内,
		该函数的操作数必须是一个成员选择器(TODO), 如 x.f
		内存空位: 有编译器添加的未使用的内存地址, 用来确保连续的成员或者元素
		相对于结构体或数组的起始地址是对齐的;(TODO)

	在类型的值在内存中对齐的情况下, 计算机的加载或写入会很高效; (TODO: 对齐)
	如果结构体成员的类型是不同的, 将相同类型的成员定义在一起可以更节约内存空间

	对于结构体:
	var x struct {
		a bool
		b int16
		c []int
	}

	在64位平台上, 其内存布局为:
		  1   1   2       4       所占字节
        -------------------------
		| a |  |  b  |          |
		-------------------------
		|       c(data)         |     \
		-------------------------     |
		|       c(len)          |     |--------> slice 的底层数据结构
		-------------------------     |
		|       c(cap)          |    /
		-------------------------
				64 位

		Sizeof(x) = 32   Alignof(x) = 8
		Sizeof(x.a) = 1    Alignof(x.a) = 1		Offsetof(x.a) = 0
		Sizeof(x.b) = 2    Alignof(x.b) = 2		Offsetof(x.b) = 2
		Sizeof(x.c) = 24   Alignof(x.c) = 8		Offsetof(x.c) = 8

	虽然包名为 unsafe, 但是以上的函数本身是安全的, 并且在做内存优化时, 可以加深
	对程序底层内存布局的理解

*/
