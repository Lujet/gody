package main

/*
* go 程序的编译比较快，即使从零开始编译也是
*
* 因为:
* 1. 所有的导入都必须在每一个源文件的开头进行显式列出, 这样编译器在确定
*	依赖性的时候就不需要读取和处理整个文件.
* 2. 包的依赖性形成有向无环图，因为没有环，所以包可以独立甚至并行编译.
* 3. go 包编译输出的目标文件不仅记录它自己的导出信息，还记录它所依赖包
*   的导出信息.
*
*
*
* 在使用空白导入的时候(_), 使用了包的副作用： 对包级别的变量执行初始化
* 表达式求值，并执行它的 init 函数.
* 使用空白引用导入额外的包，来开启程序中的可选的特性。
*
*
*
*
*
* src: 包含源文件
* pkg: 构建工具存储编译后包的位置
* bin: 可执行程序
*
* GOOS: 指定目标操作系统
* GOROOT: 指定go发行版的根目录，其中提供所有标准库的包
*
*
* go get 命令可以下载单一的包，也可以使用 ... 符号下载子树或仓库
* 该工具也计算并下载出初始包所有的依赖性.
*
*
*
* go build -i 可以将包安装在独立于构建目标的地方
*
* 为了处理底层的可移植性问题或为重要的例程提供优化版本，有一些包需要为
* 特定的平台或者处理器编译不同版本的代码，如果一个文件名包含操作系统或
* 处理器体系结构名字(net_linux.go/asm_amd64.go), go 工具只会在构建指定规
* 格的目标文件的时候才进行编译。叫做构建标签的特殊注释，提供更细粒度的控制。
* 如一个文件名包含如下注释:
*   // +build linux darwin
* 注释在包的声明之前(这不是文档注释), go build 只会在构建Linux或Mac OS X 系统
* 应用的时候才会对它进行编译，下面的注释指出任何时候都不要编译这个文件:
*   // +build ignore
*
*
*
 */
