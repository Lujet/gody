package main

/*
 * 多态:
 * - 指为不同数据类型的实体提供统一的接口，多态类型可以将自身
 *  所支持的操作套用到其他类型的值上
 * - 指代码可以根据类型的具体实现采取不同行为的能力
 *
 *
 * 接口是用来定义行为的类型，这些被定义的行为不由接口直接实现，而是通过方法由
 * 用户定义的类型实现。如果用户定义的类型实现了某个接口类型声明的一组方法，
 * 那么这个用户定义的类型的值就可以赋给这个接口类型的值, 这个赋值会把用户定义
 * 的类型的值存入接口类型的值
 *
 *
 * 对接口值方法的调用会执行接口值里存储的用户定义的类型的值的对应的方法，
 * 任何用户定义的类型都可以实现任何接口，所以对接口值方法的调用自然就是
 * 一种多态, 在这个关系里，用户定义的类型通常叫做实体类型，原因是如果离开
 * 内部存储的用户定义的类型的值的实现，接口值并没有具体的行为
 *
 */

//
// 接口值是一两个字长度的数据结构:
// 第一个字: 包含一个指向内部表的指针，这个内部表叫做iTable, 包含了所存储的
// 值的类型信息, iTable 包含了已存储的值的类型信息以及与这个值相关联的一组
// 方法
// 第二个字是一个指向所存储值的指针
//
// 将类型信息和指针组合在一起，组成接口值
//
//                user 类型值赋值后接口变量的内部布局
//     -------------------------------------------------------------------------------
//     -
//     -					   var n notifier
//     -					   n = user{"Bill"}
//     -
//     -      notifier 接口值                                    iTable
//     -
//     -  ----------------------							----------------------
//     -  --                  --							--                  --
//     -  --   iTable 的地址  --   --------------------->   --   user的类型     --
//     -  --                  --							--                  --
//     -  ----------------------		   存储的值			----------------------
//     -  --                  --			------------	--                  --
//     -  --   user 值的地址  --   ------>  -- User   --    --     方法集       --
//     -  --                  --			--	      --	--                  --
//     -  ----------------------            -------------   ----------------------
//     -
//     -------------------------------------------------------------------------------
//
//
//                user 类型指针赋值后接口变量的内部布局
//     -------------------------------------------------------------------------------
//     -
//     -					   var n notifier
//     -					   n = &user{"Bill"}
//     -
//     -      notifier 接口值                                    iTable
//     -
//     -  ----------------------							----------------------
//     -  --                  --							--                  --
//     -  --   iTable 的地址  --   --------------------->   --   *user的类型    --
//     -  --                  --							--                  --
//     -  ----------------------		   存储的值			----------------------
//     -  --                  --			------------	--                  --
//     -  --   user 值的地址  --   ------>  -- User   --    --     方法集       --
//     -  --                  --			--	      --	--                  --
//     -  ----------------------            -------------   ----------------------
//     -
//     -------------------------------------------------------------------------------
//
// 方法集
// 方法集定于了接口的接受规则

// 方法集定义了一组关联到给定类型的值或者指针的方法, 定义方法时使用的接收者
// 的类型决定了这个方法关联到值, 还是关联到指针，还是两个都关联

// 如下是go语言规范里定义的方法集的规则
// Values									Methods Receivers
// ---------------------------------------------------
//    T										(t T)
//    *T									(t T) and (t *T)

// T 类型的值的方法集只包含值接收者声明的方法
// 指向 T 类型的指针的方法集既包含值接收者声明的方法,也包含指针接收者声明的方法

// 从接收者的角度看下以上规则:
// Methods Receivers						Values
// ---------------------------------------------------
//    (t T)									T and *T
//    (t *T)								*T
// 如果使用指针接收者实现一个接口，那么只有指向类型的指针才能实现对应的
// 接口, 如果使用值接收者实现一个接口，那么类型的值和指针都能够实现对应
// 的接口.
//
// 有如上的区别因为编译器并不是总能自动获得一个值的地址
// 如下代码:

import "fmt"

type duration int

func (d *duration) pretty() string {
	return fmt.Sprintf("Duration:%d", *d)
}

func main() {
	duration(45).pretty()
	// [compiler] [E] pretty is not in method set of duration
	// 不能通过指针调用 duration(42) 的方法
	// 不能获取 duration(42) 的地址
}

// 综上, 因为不是总能获取一个值的地址，所以值的方法集只包括了使用
// 值接收者的方法
// 但是指针总能获取地址上的值，所以指针的方法集包括了使用值接收者
// 和指针接收者的方法
