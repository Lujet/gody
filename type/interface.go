package main

//
// 接口值---两个字长度的数据结构:
// 第一个字: 包含一个指向内部表的指针，这个内部表叫做iTable, 包含了所存储的
// 值的类型信息, iTable 包含了已存储的值的类型信息以及与这个值相关联的一组
// 方法
// 第二个字是一个指向所存储值的指针
//
// 将类型信息和指针组合在一起，组成接口值
//
//                user 类型值赋值后接口变量的内部布局
//     -------------------------------------------------------------------------------
//     -
//     -					   var n notifier
//     -					   n = user{"Bill"}
//     -
//     -      notifier 接口值                                    iTable
//     -
//     -  ----------------------							----------------------
//     -  --                  --							--                  --
//     -  --   iTable 的地址  --   --------------------->   --   user的类型     --
//     -  --                  --							--                  --
//     -  ----------------------		   存储的值			----------------------
//     -  --                  --			------------	--                  --
//     -  --   user 值的地址  --   ------>  -- User   --    --     方法集       --
//     -  --                  --			--	      --	--                  --
//     -  ----------------------            -------------   ----------------------
//     -
//     -------------------------------------------------------------------------------
//
//
//                user 类型指针赋值后接口变量的内部布局
//     -------------------------------------------------------------------------------
//     -
//     -					   var n notifier
//     -					   n = &user{"Bill"}
//     -
//     -      notifier 接口值                                    iTable
//     -
//     -  ----------------------							----------------------
//     -  --                  --							--                  --
//     -  --   iTable 的地址  --   --------------------->   --   *user的类型    --
//     -  --                  --							--                  --
//     -  ----------------------		   存储的值			----------------------
//     -  --                  --			------------	--                  --
//     -  --   user 值的地址  --   ------>  -- User   --    --     方法集       --
//     -  --                  --			--	      --	--                  --
//     -  ----------------------            -------------   ----------------------
//     -
//     -------------------------------------------------------------------------------
//
// 方法集
// 方法集定于了接口的接受规则

// 方法集定义了一组关联到给定类型的值或者指针的方法, 定义方法时使用的接收者
// 的类型决定了这个方法关联到值, 还是关联到指针，还是两个都关联

// 如下是go语言规范里定义的方法集的规则
// Values									Methods Receivers
// ---------------------------------------------------
//    T										(t T)
//    *T									(t T) and (t *T)

// T 类型的值的方法集只包含值接收者声明的方法
// 指向 T 类型的指针的方法集既包含值接收者声明的方法,也包含指针接收者声明的方法

// 从接收者的角度看下以上规则:
// Methods Receivers						Values
// ---------------------------------------------------
//    (t T)									T and *T
//    (t *T)								*T
// 如果使用指针接收者实现一个接口，那么只有指向类型的指针才能实现对应的
// 接口, 如果使用值接收者实现一个接口，那么类型的值和指针都能够实现对应
// 的接口.
//
// 有如上的区别因为编译器并不是总能自动获得一个值的地址
// 如下代码:

import "fmt"

type duration int

func (d *duration) pretty() string {
	return fmt.Sprintf("Duration:%d", *d)
}

func main() {
	duration(45).pretty()
	// [compiler] [E] pretty is not in method set of duration
	// 不能通过指针调用 duration(42) 的方法
	// 不能获取 duration(42) 的地址
}

// 综上, 因为不是总能获取一个值的地址，所以值的方法集只包括了使用
// 值接收者的方法
// 但是指针总能获取地址上的值，所以指针的方法集包括了使用值接收者
// 和指针接收者的方法
