package main

import "fmt"

/*
 * 方法能为用户定义的类型添加新的行为
 * 方法实际上也是函数，只是这个函数与类型绑定，只有方法的接收者才可调用方法
 * 关键字 func 和函数名之间的参数被称为接收者, 将函数和接收者的类型绑定到
 * 一起，有接收者的函数称为方法
 *
 * go 语言里有两种类型的接收者: 值接收者和指针接收者
 *
 */

type user struct {
	name  string
	email string
}

// notify 使用值接收者实现了一个方法
func (u user) notify() {
	fmt.Printf("Sending User Email To  %s<%s>\n", u.name, u.email)
}

// 如果使用值接收者声明方法， 调用时会使用这个值的一个副本来执行.

// 也可以使用指针调用使用值接收者声明的方法
// lisa := &user{"Datou", "datou@email.com"}
// lisa.notify()
// 为了支持这种方法调用, go 语言调整了指针的值，来符合方法接收者的定义
// (*lisa).notify(), 指针被解引用为值，符合了值接收者的要求，注意: notify
// 操作的是一个副本，只不过这次操作的是从 lisa 指针指向的值的副本.

// changeEmail 使用指针接收者实现了一个方法
// changeEmail 的调用对值做的修改会反映在 lisa 指针所指向的值上,
func (u *user) changeEmail(email string) {
	u.email = email
}

// 值接收者使用值的副本来调用方法，而指针接收者使用实际值来调用方法,
// 也可以使用一个值来调用使用指针接收者声明的方法
// bill := user{"xiaohong", "xiaohong@email.com"}
// bill.changeEmail("xiaohong@qq.com")
// go 语言对值做了调整，使之符合函数的接收者并进行调用
// (&bill).changeEmail("xiaohong@qq.com")

// go 语言既允许使用值，也允许使用指针来调用方法，不必严格符合接收者的类型

// ----------------------------------------------------------------------------
/*
 * 类型的本质:
 * 在声明一个类型时，应该考虑这个类型的本质是什么?
 * 如果给这个类型增加或删除某个值，是要创建一个新值，要是要更改当前的值?
 * 创建新值，该类型的方法使用值接收者
 * 修改当前值，该类型的方法使用指针接收者
 * 以上逻辑决定了程序内部传递这个类型的值的方式, 是按值做传递还是按指针做传递,
 * 保持传递的一致性很重要，原则为: 不要只关注某个方法是如何处理这个值的，而是
 * 关注这个值的本质。
 * 这里的一致性: 一般情况下，一个类型的所有方法要么都用值作为接收者，要么
 * 都用指针作为接收者
 */

//
//  内置类型: 数值类型,字符串类型和布尔类型
//  这些类型本质上是原始的类型，当对这些值进行增加或删除的时候，会创建一个新值
//  所以当把这些类型的值传递给方法或函数时，应传递一个对应值的副本
//
//
//  引用类型: 切片,映射,通道,接口和函数类型
//  当声明上述类型时，创建的变量被称作标头值(header), 每个引用类型创建的标头值
//  是包含一个指向底层数据结构的指针，每个引用类型还包含一组独特的字段，用于管
//  理底层数据结构。
//  因为标头值是为复制而设计的，所以永远不需要共享一个引用类型的值; 标头值
//  里包含一个指针，因此通过复制传递一个引用类型的值的副本，本质上就是在共享
//  底层数据结构(直接传递，而不需要取地址)

// 当要围绕相关的内置类型或者引用类型来声明用户定义的行为时，直接基于已有的类型
// 来声明定义用户定义的类型比较好用
// type IP []byte
// 注: 编译器只允许为命名的用户定义的类型声明方法
// 一个值接收者通过复制(副本)来传递引用，从而不需要通过指针来共享引用类型的值,
// 这种传递方法也可以应用到函数或者方法的参数传递, 即调用者将引用类型的值的副
// 本传入这个函数，而不是通过引用共享给这个函数, 这种方法也适用于函数的返回值;
// 引用类型的值在其他方面像原始的数据类型的值一样对待

// -----------------------------------------------------------------------------
// 结构类型
// 结构类型可以用来描述一组数据集, 这组值的本质即可以是原始的，也可以是非原始的
// 多数情况下，结构类型的本质并不是原始的, 而是非原始的，这种情况下对这个类型
// 的值做增加或者删除的操作应该更改值本身。当需要修改值本身时，在程序中其他地
// 方，需要使用指针来共享这个值。

// File 表示一个打开的文件描述符
// type File struct {
// 	*file
// }

// todo: 理解
// file 是 *File 的实际表示
// 额外的一层结构保证没有哪个os的客户端能够覆盖这些数据，
// 如果覆盖这些数据，可能在变量终结时关闭错误的文件描述符
// type file struct {
// 	fd      int
// 	name    string
// 	dirinfo *dirInfo // 除了目录结构，此字段为 nil
// 	nepipe  int32    // Write 操作时遇到连续的EPIPE的次数, EPIPE ???
// }

// go语言实战, Page94
// todo: 理解
// 上面为标准库里声明的 File 类型，这个类型的本质是非原始的，其值实际上不能安全
// 复制; 上面代码的注释解释了不安全的原因。因为没有方法阻止程序员进行复制，所
// 以 File 类型的实现使用了一个嵌入的指针，指向一个未公开的类型。正是这层额外的
// 内嵌类型阻止了复制，不是所有的结构类型都需要或者应该实现类似的额外保护。应该
// 识别出每个类型的本质, 并使用这个本质来决定如何阻止类型。
//
